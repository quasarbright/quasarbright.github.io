<!DOCTYPE html>
<html lang="en" >
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Fractal Curve Editor</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js"></script>
  <script>
    document.addEventListener("DOMContentLoaded", function() {
      // Wait for KaTeX to be loaded
      setTimeout(function() {
        renderMathInElement(document.body, {
          delimiters: [
            {left: "\\[", right: "\\]", display: true},
            {left: "\\(", right: "\\)", display: false}
          ]
        });
      }, 100);
    });
  </script>
  <style>
    body {
      background-color: black;
      color: white;
      font-family: sans-serif;
    }
    canvas {
      border: 1px solid white;
      cursor: crosshair;
      background-color: black;
      display: block;
      margin-bottom: 20px;
    }
    button {
      margin-top: 10px;
      margin-right: 10px;
      background-color: #222;
      color: white;
      border: 1px solid white;
      padding: 5px 10px;
      cursor: pointer;
    }
    button:hover {
      background-color: #444;
    }
    #status {
      margin-top: 10px;
    }
    .control-group {
      margin-bottom: 10px;
    }
    .grid-controls {
      display: flex;
      align-items: center;
      margin-bottom: 10px;
    }
    .grid-controls > * {
      margin-right: 10px;
    }
    input[type="number"] {
      background-color: #222;
      color: white;
      border: 1px solid white;
      padding: 5px;
      width: 80px;
    }
    select {
      background-color: #222;
      color: white;
      border: 1px solid white;
      padding: 5px 10px;
      margin-right: 10px;
    }
  </style>
</head>
<body>
  <h1>Fractal Curve Editor</h1>
  <canvas id="canvas" width="500" height="500"></canvas><br />
  <div style="margin-bottom: 10px;">
    <select id="presetSelect" style="background-color: #222; color: white; border: 1px solid white; padding: 5px 10px; margin-right: 10px;">
      <option value="">Select a preset curve...</option>
      <option value="koch">Koch Curve</option>
      <option value="sierpinski">Sierpinski Triangle</option>
      <option value="crosses">Crosses</option>
      <option value="triangle_tiling">Triangle Tiling</option>
      <option value="levy">Levy C Curve</option>
      <option value="minkowski">Minkowski Sausage Curve</option>
      <option value="terdragon">Terdragon Curve</option>
      <option value="roots">Roots</option>
    </select>
    <button id="loadPreset">Load Preset</button>
  </div>
  
  <div class="grid-controls">
    <label for="gridType">Grid: </label>
    <select id="gridType">
      <option value="none">None</option>
      <option value="square">Square</option>
      <option value="hex">Hexagonal</option>
    </select>
    <label for="gridSpacing">Spacing: </label>
    <input type="number" id="gridSpacing" min="0.05" max="2" value="0.5" step="0.05">
    <div style="display: flex; align-items: center; margin-left: 10px;">
      <input type="checkbox" id="snapToGrid" disabled>
      <label for="snapToGrid">Snap to grid</label>
    </div>
  </div>
  
  <button id="reset">Reset</button>
  <button id="resetCamera">Reset Camera</button>
  <button id="iterate">Iterate</button>
  <div id="status"></div>
  
  <div style="margin-top: 30px; border-top: 1px solid #444; padding-top: 20px;">
    <h2>How to Use the Fractal Curve Editor</h2>
    <p>
      This is an interactive fractal curve editor that allows you to create and explore custom fractal curves.
      You can design your own seed pattern and see how it evolves through multiple iterations.
    </p>
    
    <h3>Controls:</h3>
    <ul>
      <li><strong>Create Seed Pattern:</strong> Click on the canvas to add points to your seed pattern (before iterating), or load a preset curve</li>
      <li><strong>Move Points:</strong> Drag the red points to modify your seed pattern. This can be done during seed creation and also after iterating.</li>
      <li><strong>Iterate:</strong> Click the "Iterate" button to replace each segment with a copy of the seed</li>
      <li><strong>Pan:</strong> Click and drag on the canvas to move the view</li>
      <li><strong>Zoom:</strong> Scroll to zoom in and out around the mouse cursor</li>
      <li><strong>Reset:</strong> Click the "Reset" button to start over with a new seed pattern</li>
      <li><strong>Reset Camera:</strong> Click the "Reset Camera" button to center the view</li>
    </ul>
    
    <div style="margin-top: 20px;">
      <h2>The Mathematics Behind Fractal Curves</h2>
      
      <h3>Fractal Generation</h3>
      <p>
        These fractal curves are created through an iterative process of replacing each line segment with a scaled, 
        rotated, and translated copy of a "seed pattern." This process is repeated for each new line segment 
        created, leading to increasingly complex patterns with self-similarity at different scales.
      </p>
      <p>
        The process works as follows:
      </p>
      <ol>
        <li>Start with a seed pattern (the points you create by clicking)</li>
        <li>For each line segment in the current curve, replace it with a transformed copy of the seed pattern</li>
        <li>Repeat step 2 for each new iteration</li>
      </ol>
      
      <h3>Fractal Dimension</h3>
      <p>
        The fractal dimension is a measure of how "rough" or complex a fractal is.
        Unlike regular shapes that have integer dimensions (lines are 1D, squares are 2D), fractals can have 
        non-integer dimensions. Of course, what you see on your screen is just a bunch of line segments if you
        zoom in enough (which is 1D), but the fractal dimension displayed is the fractal dimension of the curve you would get if you
        performed infinite iterations. This "true fractal" would be infinitely complex no matter how much you zoom in.
      </p>
      <p>
        For self-similar fractals like those created in this editor, the dimension \(D\) is calculated by solving 
        the equation:
      </p>
      <p style="text-align: center; margin: 20px 0;">
        \[ \sum_{i} (r_i^D) = 1 \]
      </p>
      <p>
        where \(r_i\) is the length of the \(i\)-th line segment of your seed pattern.
      </p>
      <p>
        The resulting dimension \(D\) tells us how "space-filling" the fractal is:
      </p>
      <ul>
        <li>\(D = 1\): The curve is essentially a line</li>
        <li>\(1 < D < 2\): The fractal is "rough" and will never look like a line no matter how much you zoom in, but it doesn't fill a "solid" 2D area</li>
        <li>\(D \ge 2\): The fractal fills a "solid" 2D area</li>
      </ul>
      <p>
        For example, the Koch snowflake curve has \(D \approx 1.26\), while the Hilbert curve has \(D = 2\).
      </p>
      <p>
        For curves which grow larger and larger after more iterations, the fractal dimension is undefined. This is because
        the curve doesn't "converge" in this case. There is only a fractal dimension when iterating brings you closer and closer to a true fractal.
      </p>
      <p>for more information on the math behind fractal dimension, check out this great video by 3blue1brown, which is what inspired this app:</p>
      <iframe width="560" height="315" src="https://www.youtube.com/embed/gB9n2gHsHN4?si=jIHznkcWJS36S5VW" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
    </div>
  </div>
  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const statusDiv = document.getElementById("status");
    const gridTypeSelect = document.getElementById("gridType");
    const gridSpacingInput = document.getElementById("gridSpacing");

    // Grid settings
    let gridType = "none";
    let gridSpacing = 0.5;
    let snapToGrid = false;
    let ghostPoint = null;

    // Preset curves data structure
    const presetCurves = {
      koch: [
        [0, 0],
        [1/3, 0],
        [0.5, -Math.sqrt(3)/6],
        [2/3, 0],
        [1, 0]
      ],
      sierpinski: [
        [0, 0],
        [0.5, 0],
        [0.25, -Math.sqrt(3)/4],
        [0.75, -Math.sqrt(3)/4],
        [0.5, 0],
        [1, 0]
      ],
      crosses: [
        [0, 0],
        [0.5, 0],
        [0.5,-0.25],
        [0.5, 0],
        [1, 0]
      ],
      triangle_tiling: [
        [0, 0],
        [0.5, -Math.sqrt(3)/2],
        [1, 0],
      ],
      levy: [
        [0, 0],
        [0,-0.5],
        [0.5,-0.5],
        [1,-0.5],
        [1, 0],
      ],
      minkowski: [
        [0, 0],
        [0.25, 0],
        [0.25, -.25],
        [0.5, -.25],
        [0.5, 0],
        [0.5, 0.25],
        [0.75, 0.25],
        [0.75, 0],
        [1, 0],
      ],
      terdragon: [
        [0,0],
        [0.5, -1 / (Math.sqrt(3) * 2)],
        [0.5, 1 / (Math.sqrt(3) * 2)],
        [1,0],
      ],
      roots: [
        [0,0],
        [0,-0.5],
        [0.5,0],
        [1,0],
      ],
    };

    let seed = [[0, 0], [1, 0]];

    let iterationCount = 1;
    let iterated = false;

    let offsetX = 0, offsetY = 0;
    let scale = 1;
    
    // Animation variables
    let isAnimating = false;
    let animationStartTime = 0;
    let animationDuration = 500; // Fixed at 500ms
    let fromIterationCount = 1;
    let toIterationCount = 2;

    let isDraggingCanvas = false;
    let dragStart = { x: 0, y: 0 };
    let isDraggingSeedVertex = false;
    let draggedVertexIndex = -1;
    let mouseMovedSinceDown = false;
    let mouseDownPos = { x: 0, y: 0 };
    const dragThreshold = 5; // Pixel threshold for considering a movement as a drag

    let hoveredVertexIndex = -1;

    const dotRadiusPx = 6;
    const seedPointRadius = 4;

    const linePaddingRatio = 0.15;

    const baseStartCanvas = [linePaddingRatio * canvas.width, canvas.height * .5];
    const baseEndCanvas = [canvas.width - linePaddingRatio * canvas.width, canvas.height * .5];

    function seedPointToCanvas([nx, ny]) {
      const dx = baseEndCanvas[0] - baseStartCanvas[0];
      const dy = baseEndCanvas[1] - baseStartCanvas[1];
      const lengthBase = Math.sqrt(dx*dx + dy*dy);
      const perpX = -dy / lengthBase;
      const perpY = dx / lengthBase;

      const x = baseStartCanvas[0] + nx * dx + ny * lengthBase * perpX;
      const y = baseStartCanvas[1] + nx * dy + ny * lengthBase * perpY;
      return [x, y];
    }

    function canvasToSeedPoint([cx, cy]) {
      const dx = baseEndCanvas[0] - baseStartCanvas[0];
      const dy = baseEndCanvas[1] - baseStartCanvas[1];
      const lengthBase = Math.sqrt(dx*dx + dy*dy);

      const vx = cx - baseStartCanvas[0];
      const vy = cy - baseStartCanvas[1];

      const dot = (vx*dx + vy*dy) / (lengthBase*lengthBase);
      const perpDot = (vx*(-dy) + vy*dx) / (lengthBase*lengthBase);

      return [dot, perpDot];
    }

    function computeFractalPoints(iterCount) {
      let currentPoints = [baseStartCanvas, baseEndCanvas];

      for (let iter = 0; iter < iterCount; iter++) {
        let newPoints = [];
        for (let i = 0; i < currentPoints.length - 1; i++) {
          const segStart = currentPoints[i];
          const segEnd = currentPoints[i + 1];

          const transformedPoints = seed.map(([nx, ny]) => {
            const vx = segEnd[0] - segStart[0];
            const vy = segEnd[1] - segStart[1];
            const len = Math.sqrt(vx*vx + vy*vy);
            const px = -vy / len;
            const py = vx / len;

            const x = segStart[0] + nx * vx + ny * len * px;
            const y = segStart[1] + nx * vy + ny * len * py;
            return [x, y];
          });

          if (i > 0) transformedPoints.shift();
          newPoints.push(...transformedPoints);
        }
        currentPoints = newPoints;
      }
      return currentPoints;
    }

    function computeFractalDimension() {
      let maxLen = 0;
      const lengths = [];

      for (let i = 0; i < seed.length - 1; i++) {
        const [x1, y1] = seed[i];
        const [x2, y2] = seed[i + 1];
        const dx = x2 - x1;
        const dy = y2 - y1;
        const len = Math.sqrt(dx * dx + dy * dy);
        if (len > maxLen) maxLen = len;
        lengths.push(len);
      }
      if (maxLen >= 1) return NaN;

      const tolerance = 1e-10;
      const maxIterations = 100;
      let D = 1.0;

      function f(D) {
        return lengths.reduce((sum, l) => sum + Math.pow(l, D), 0) - 1;
      }

      function fPrime(D) {
        return lengths.reduce((sum, l) => sum + Math.pow(l, D) * Math.log(l), 0);
      }

      for (let i = 0; i < maxIterations; i++) {
        const y = f(D);
        const yPrime = fPrime(D);
        if (Math.abs(yPrime) < 1e-12) break;
        const nextD = D - y / yPrime;
        if (Math.abs(nextD - D) < tolerance) return nextD;
        D = nextD;
      }
      return NaN;
    }

    function draw(animationProgress = -1) {
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      ctx.setTransform(scale, 0, 0, scale, offsetX, offsetY);
      
      // Draw grid if enabled
      drawGrid();
      
      ctx.lineWidth = 1 / scale;
      ctx.strokeStyle = "white";

      let fractalPoints;
      
      if (isAnimating && animationProgress >= 0 && animationProgress <= 1) {
        // During animation, interpolate between the two iteration levels
        const fromPoints = iterated ? 
          computeFractalPoints(fromIterationCount) : 
          seed.map(seedPointToCanvas);
          
        const toPoints = computeFractalPoints(toIterationCount);
        
        // Interpolate between the two sets of points
        fractalPoints = interpolatePoints(fromPoints, toPoints, animationProgress);
      } else if (iterated) {
        fractalPoints = computeFractalPoints(iterationCount);
      } else {
        fractalPoints = seed.map(seedPointToCanvas);
      }

      ctx.beginPath();
      ctx.moveTo(fractalPoints[0][0], fractalPoints[0][1]);
      for (let pt of fractalPoints.slice(1)) {
        ctx.lineTo(pt[0], pt[1]);
      }
      ctx.stroke();

      ctx.setTransform(1, 0, 0, 1, 0, 0);
      
      // Draw ghost point for snapping (only during creation phase)
      if (!iterated && ghostPoint && snapToGrid) {
        const [cx, cy] = seedPointToCanvas(ghostPoint);
        const sx = cx * scale + offsetX;
        const sy = cy * scale + offsetY;

        ctx.beginPath();
        ctx.fillStyle = "rgba(150, 150, 150, 0.7)";
        ctx.arc(sx, sy, seedPointRadius, 0, 2 * Math.PI);
        ctx.fill();
      }
      
      // Draw seed points
      for (let i = 0; i < seed.length; i++) {
        const [cx, cy] = seedPointToCanvas(seed[i]);
        const sx = cx * scale + offsetX;
        const sy = cy * scale + offsetY;

        ctx.beginPath();
        if (i === 0 || i === seed.length -1) {
          ctx.fillStyle = "white";
        } else {
          ctx.fillStyle = (i === hoveredVertexIndex) ? "lime" : "red";
        }
        ctx.arc(sx, sy, seedPointRadius, 0, 2 * Math.PI);
        ctx.fill();
      }

      let status = iterated ? `iterations: ${iterationCount - 1}` : "creating seed";
      const dim = computeFractalDimension();
      if (!isNaN(dim)) {
        status += `<br>fractal dimension: ${dim.toFixed(5)}`;
      } else {
        status += `<br>fractal dimension: undefined`;
      }
      statusDiv.innerHTML = status;
    }

    // Function to draw grid based on current view
    function drawGrid() {
      if (gridType === "none") return;
      
      // Calculate visible area in mathematical space
      // Convert from canvas coordinates to mathematical space
      const canvasToMath = (x, y) => {
        // First convert from canvas pixel to canvas space (accounting for scale and offset)
        const canvasX = (x - offsetX) / scale;
        const canvasY = (y - offsetY) / scale;
        // Then convert from canvas space to mathematical space
        return canvasToSeedPoint([canvasX, canvasY]);
      };
      
      const visibleLeftTop = canvasToMath(0, 0);
      const visibleRightBottom = canvasToMath(canvas.width, canvas.height);
      
      // Expand boundaries to ensure we cover the visible area
      const visibleLeft = Math.min(visibleLeftTop[0], visibleRightBottom[0]) - 1;
      const visibleRight = Math.max(visibleLeftTop[0], visibleRightBottom[0]) + 1;
      const visibleTop = Math.min(visibleLeftTop[1], visibleRightBottom[1]) - 1;
      const visibleBottom = Math.max(visibleLeftTop[1], visibleRightBottom[1]) + 1;
      
      // Grid spacing in mathematical units
      const mathSpacing = gridSpacing;
      
      // Set grid style
      ctx.lineWidth = 0.5 / scale;
      ctx.strokeStyle = "rgba(150, 150, 150, 0.5)";
      
      if (gridType === "square") {
        // Calculate grid boundaries aligned with mathematical (0,0)
        const startX = Math.floor(visibleLeft / mathSpacing) * mathSpacing;
        const startY = Math.floor(visibleTop / mathSpacing) * mathSpacing;
        const endX = Math.ceil(visibleRight / mathSpacing) * mathSpacing;
        const endY = Math.ceil(visibleBottom / mathSpacing) * mathSpacing;
        
        // Draw vertical grid lines
        for (let x = startX; x <= endX; x += mathSpacing) {
          // Convert mathematical coordinates to canvas coordinates
          const startPoint = seedPointToCanvas([x, visibleTop]);
          const endPoint = seedPointToCanvas([x, visibleBottom]);
          
          ctx.beginPath();
          ctx.moveTo(startPoint[0], startPoint[1]);
          ctx.lineTo(endPoint[0], endPoint[1]);
          ctx.stroke();
        }
        
        // Draw horizontal grid lines
        for (let y = startY; y <= endY; y += mathSpacing) {
          // Convert mathematical coordinates to canvas coordinates
          const startPoint = seedPointToCanvas([visibleLeft, y]);
          const endPoint = seedPointToCanvas([visibleRight, y]);
          
          ctx.beginPath();
          ctx.moveTo(startPoint[0], startPoint[1]);
          ctx.lineTo(endPoint[0], endPoint[1]);
          ctx.stroke();
        }
      } else if (gridType === "hex") {
        // For equilateral triangles with side length 1, we need:
        // - The spacing between parallel lines to be sin(60°) = √3/2
        // - The x-intercepts of the diagonal lines to be at intervals of 1
        
        const unitLength = mathSpacing; // This is our unit length (side of equilateral triangle)
        const lineSpacing = (Math.sqrt(3) / 2) * unitLength; // Height of equilateral triangle
        
        // Calculate visible area with padding
        const padding = 2 * unitLength;
        const extendedLeft = visibleLeft - padding;
        const extendedRight = visibleRight + padding;
        const extendedTop = visibleTop - padding;
        const extendedBottom = visibleBottom + padding;
        
        // Ensure grid is centered at (0,0)
        
        // For horizontal lines (at y = 0, ±lineSpacing, ±2*lineSpacing, etc.)
        const horizStartY = Math.floor(extendedTop / lineSpacing) * lineSpacing;
        const horizEndY = Math.ceil(extendedBottom / lineSpacing) * lineSpacing;
        
        // Draw horizontal lines
        for (let y = horizStartY; y <= horizEndY; y += lineSpacing) {
          const startPoint = seedPointToCanvas([extendedLeft, y]);
          const endPoint = seedPointToCanvas([extendedRight, y]);
          
          ctx.beginPath();
          ctx.moveTo(startPoint[0], startPoint[1]);
          ctx.lineTo(endPoint[0], endPoint[1]);
          ctx.stroke();
        }
        
        // For 60° lines (y = √3 * x + b)
        // The x-intercepts should be at intervals of unitLength
        const x60Offset = Math.floor(extendedLeft / unitLength) * unitLength;
        
        for (let xIntercept = x60Offset; xIntercept <= extendedRight; xIntercept += unitLength) {
          // Calculate start and end points for a line with this x-intercept
          const startX = extendedLeft;
          const startY = -Math.sqrt(3) * xIntercept + Math.sqrt(3) * startX;
          const endX = extendedRight;
          const endY = -Math.sqrt(3) * xIntercept + Math.sqrt(3) * endX;
          
          const startPoint = seedPointToCanvas([startX, startY]);
          const endPoint = seedPointToCanvas([endX, endY]);
          
          ctx.beginPath();
          ctx.moveTo(startPoint[0], startPoint[1]);
          ctx.lineTo(endPoint[0], endPoint[1]);
          ctx.stroke();
        }
        
        // For 120° lines (y = -√3 * x + b)
        // The x-intercepts should be at intervals of unitLength
        const x120Offset = Math.floor(extendedLeft / unitLength) * unitLength;
        
        for (let xIntercept = x120Offset; xIntercept <= extendedRight; xIntercept += unitLength) {
          // Calculate start and end points for a line with this x-intercept
          const startX = extendedLeft;
          const startY = Math.sqrt(3) * xIntercept - Math.sqrt(3) * startX;
          const endX = extendedRight;
          const endY = Math.sqrt(3) * xIntercept - Math.sqrt(3) * endX;
          
          const startPoint = seedPointToCanvas([startX, startY]);
          const endPoint = seedPointToCanvas([endX, endY]);
          
          ctx.beginPath();
          ctx.moveTo(startPoint[0], startPoint[1]);
          ctx.lineTo(endPoint[0], endPoint[1]);
          ctx.stroke();
        }
        
        // Draw a visual indicator for a unit equilateral triangle if close to origin
        if (Math.abs(offsetX) < canvas.width && Math.abs(offsetY) < canvas.height && scale > 50) {
          // Points for equilateral triangle with side length 1
          const triPoints = [
            [0, 0],
            [1, 0],
            [0.5, Math.sqrt(3)/2]
          ].map(p => seedPointToCanvas(p));
          
          ctx.beginPath();
          ctx.moveTo(triPoints[0][0], triPoints[0][1]);
          ctx.lineTo(triPoints[1][0], triPoints[1][1]);
          ctx.lineTo(triPoints[2][0], triPoints[2][1]);
          ctx.closePath();
          ctx.strokeStyle = "rgba(255, 255, 0, 0.5)";
          ctx.stroke();
          ctx.strokeStyle = "rgba(150, 150, 150, 0.5)";
        }
      }
    }

    function getSeedVertexUnderMouse(mx, my) {
      for (let i = 0; i < seed.length; i++) {
        if (i === 0 || i === seed.length - 1) continue;
        const [cx, cy] = seedPointToCanvas(seed[i]);
        const sx = cx * scale + offsetX;
        const sy = cy * scale + offsetY;
        const dx = mx - sx;
        const dy = my - sy;
        if (dx * dx + dy * dy <= dotRadiusPx * dotRadiusPx) {
          return i;
        }
      }
      return -1;
    }

    function updateSeedVertexPosition(index, fx, fy) {
      if (index === 0 || index === seed.length -1) return;
      seed[index] = canvasToSeedPoint([fx, fy]);
    }

    // Function to find nearest grid intersection point
    function findNearestGridIntersection(mathX, mathY) {
      if (gridType === "none") return [mathX, mathY];
      
      if (gridType === "square") {
        // For square grid, simply round to nearest grid spacing
        const nearestX = Math.round(mathX / gridSpacing) * gridSpacing;
        const nearestY = Math.round(mathY / gridSpacing) * gridSpacing;
        return [nearestX, nearestY];
      } else if (gridType === "hex") {
        // For hexagonal grid, we need to find the nearest intersection of our three line types
        
        // Height of equilateral triangle
        const height = (Math.sqrt(3) / 2) * gridSpacing;
        
        // First, find the nearest horizontal line
        const nearestY = Math.round(mathY / height) * height;
        
        // For the x-coordinate, it depends on which horizontal line we're on
        // If we're on an even-indexed horizontal line, intersections are at integer multiples of gridSpacing
        // If we're on an odd-indexed horizontal line, intersections are offset by gridSpacing/2
        const lineIndex = Math.round(nearestY / height);
        let xOffset = (lineIndex % 2 === 0) ? 0 : gridSpacing / 2;
        
        // Find nearest x-coordinate on this horizontal line
        const nearestX = Math.round((mathX - xOffset) / gridSpacing) * gridSpacing + xOffset;
        
        return [nearestX, nearestY];
      }
      
      return [mathX, mathY];
    }
    
    canvas.addEventListener("mousemove", e => {
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;

      // Only consider it a drag if movement exceeds threshold
      const dx = mx - mouseDownPos.x;
      const dy = my - mouseDownPos.y;
      const distSquared = dx * dx + dy * dy;
      
      if (distSquared > dragThreshold * dragThreshold) {
        mouseMovedSinceDown = true;
      }

      // Calculate mathematical coordinates
      const fx = (mx - offsetX) / scale;
      const fy = (my - offsetY) / scale;
      const mathPoint = canvasToSeedPoint([fx, fy]);
      
      // Update ghost point for snapping (only during creation phase)
      if (!iterated && snapToGrid) {
        ghostPoint = findNearestGridIntersection(mathPoint[0], mathPoint[1]);
        draw();
      } else {
        // Only redraw if we had a ghost point before
        if (ghostPoint) {
          ghostPoint = null;
          draw();
        }
      }

      if (isDraggingSeedVertex) {
        if (snapToGrid) {
          const snappedPoint = findNearestGridIntersection(mathPoint[0], mathPoint[1]);
          updateSeedVertexPosition(draggedVertexIndex, ...seedPointToCanvas(snappedPoint));
        } else {
          updateSeedVertexPosition(draggedVertexIndex, fx, fy);
        }
        draw();
        return;
      }

      const hovered = getSeedVertexUnderMouse(mx, my);
      if (hovered !== hoveredVertexIndex) {
        hoveredVertexIndex = hovered;
        canvas.style.cursor = hovered !== -1 ? "pointer" : (iterated ? "grab" : "crosshair");
        draw();
      }

      if (isDraggingCanvas) {
        offsetX = e.clientX - dragStart.x;
        offsetY = e.clientY - dragStart.y;
        draw();
      }
    });

    canvas.addEventListener("mousedown", e => {
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;

      mouseMovedSinceDown = false;
      mouseDownPos.x = mx;
      mouseDownPos.y = my;

      const vertexIndex = getSeedVertexUnderMouse(mx, my);
      if (vertexIndex !== -1) {
        isDraggingSeedVertex = true;
        draggedVertexIndex = vertexIndex;
        canvas.style.cursor = "grabbing";
        return;
      }

      isDraggingCanvas = true;
      dragStart.x = e.clientX - offsetX;
      dragStart.y = e.clientY - offsetY;
      canvas.style.cursor = "grabbing";
    });

    canvas.addEventListener("mouseup", e => {
      if (isDraggingSeedVertex) {
        isDraggingSeedVertex = false;
        draggedVertexIndex = -1;
        canvas.style.cursor = hoveredVertexIndex !== -1 ? "pointer" : "grab";
        return;
      }

      if (isDraggingCanvas) {
        isDraggingCanvas = false;
        canvas.style.cursor = hoveredVertexIndex !== -1 ? "pointer" : "grab";
        return;
      }
    });

    canvas.addEventListener("mouseleave", e => {
      if (isDraggingSeedVertex) {
        isDraggingSeedVertex = false;
        draggedVertexIndex = -1;
      }
      if (isDraggingCanvas) {
        isDraggingCanvas = false;
      }
      hoveredVertexIndex = -1;
      canvas.style.cursor = "crosshair";
      draw();
    });

    canvas.addEventListener("wheel", e => {
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;

      const wx = (mouseX - offsetX) / scale;
      const wy = (mouseY - offsetY) / scale;

      const zoom = e.deltaY < 0 ? 1.1 : 0.9;
      scale *= zoom;

      offsetX = mouseX - wx * scale;
      offsetY = mouseY - wy * scale;

      draw();
    });

    canvas.addEventListener("click", e => {
      if (iterated || isDraggingSeedVertex || isDraggingCanvas || mouseMovedSinceDown) return;

      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;

      const fx = (mx - offsetX) / scale;
      const fy = (my - offsetY) / scale;
      let newPoint = canvasToSeedPoint([fx, fy]);
      
      // If snap to grid is enabled, use the ghost point
      if (snapToGrid && ghostPoint) {
        newPoint = ghostPoint;
      }

      seed.splice(seed.length - 1, 0, newPoint);
      draw();
    });

    // Interpolate between two sets of points
    function interpolatePoints(fromPoints, toPoints, progress) {
      // Map the original segments to the new segments
      const result = [];
      
      // Find the mapping between original segments and new segments
      const segmentMap = mapSegmentsForAnimation(fromPoints, toPoints);
      
      // For each segment in the original curve
      for (let i = 0; i < segmentMap.length; i++) {
        const { originalStart, originalEnd, newPoints } = segmentMap[i];
        
        // Add the start point of this segment
        if (i === 0 || result[result.length - 1][0] !== originalStart[0] || result[result.length - 1][1] !== originalStart[1]) {
          result.push(originalStart);
        }
        
        // If there are intermediate points in this segment
        if (newPoints.length > 0) {
          // Calculate the midpoint of the original segment
          const midX = originalStart[0] + (originalEnd[0] - originalStart[0]) * 0.5;
          const midY = originalStart[1] + (originalEnd[1] - originalStart[1]) * 0.5;
          
          // For each new point, interpolate from the midpoint to its final position
          for (const newPoint of newPoints) {
            // Start from a position along the original segment
            const startX = midX;
            const startY = midY;
            
            // Interpolate to the final position
            result.push([
              startX + (newPoint[0] - startX) * progress,
              startY + (newPoint[1] - startY) * progress
            ]);
          }
        }
        
        // Add the end point of this segment
        result.push(originalEnd);
      }
      
      return result;
    }
    
    // Map original segments to new segments for animation
    function mapSegmentsForAnimation(fromPoints, toPoints) {
      const result = [];
      
      // If we're just starting with a seed pattern, handle it differently
      if (fromPoints.length <= 2) {
        // Just return a single segment with all the new points
        return [{
          originalStart: fromPoints[0],
          originalEnd: fromPoints[fromPoints.length - 1],
          newPoints: toPoints.slice(1, -1)
        }];
      }
      
      // Find the corresponding segments
      let toIndex = 0;
      
      for (let i = 0; i < fromPoints.length - 1; i++) {
        const originalStart = fromPoints[i];
        const originalEnd = fromPoints[i + 1];
        const newPoints = [];
        
        // Find the matching end point in the new curve
        let matchFound = false;
        while (toIndex < toPoints.length - 1) {
          // Add intermediate points
          newPoints.push(toPoints[toIndex]);
          toIndex++;
          
          // Check if we've found the matching end point
          if (Math.abs(toPoints[toIndex][0] - originalEnd[0]) < 0.001 && 
              Math.abs(toPoints[toIndex][1] - originalEnd[1]) < 0.001) {
            matchFound = true;
            break;
          }
        }
        
        // If we found a match, add this segment mapping
        if (matchFound) {
          result.push({
            originalStart,
            originalEnd,
            newPoints: newPoints.slice(1)  // Skip the start point as it's already included
          });
        }
      }
      
      // If we couldn't map properly, fall back to a simpler approach
      if (result.length === 0) {
        return [{
          originalStart: fromPoints[0],
          originalEnd: fromPoints[fromPoints.length - 1],
          newPoints: toPoints.slice(1, -1)
        }];
      }
      
      return result;
    }
    
    // Animation frame function
    function animateIteration(timestamp) {
      if (!animationStartTime) animationStartTime = timestamp;
      
      const elapsed = timestamp - animationStartTime;
      const progress = Math.min(elapsed / animationDuration, 1);
      
      draw(progress);
      
      if (progress < 1) {
        requestAnimationFrame(animateIteration);
      } else {
        // Animation complete
        isAnimating = false;
        animationStartTime = 0;
        iterationCount = toIterationCount;
        draw();
      }
    }

    document.getElementById("iterate").addEventListener("click", () => {
      if (isAnimating) return; // Don't start a new animation if one is in progress
      
      if (!iterated) {
        iterated = true;
        fromIterationCount = 1;
        toIterationCount = 2;
        canvas.style.cursor = "grab";
        updateSnapToGridState();
      } else {
        fromIterationCount = iterationCount;
        toIterationCount = iterationCount + 1;
      }
      
      // Start animation
      isAnimating = true;
      animationStartTime = 0;
      requestAnimationFrame(animateIteration);
    });

    document.getElementById("reset").addEventListener("click", () => {
      seed = [[0, 0], [1, 0]];
      iterationCount = 1;
      iterated = false;
      offsetX = 0;
      offsetY = 0;
      scale = 1;
      hoveredVertexIndex = -1;
      isDraggingSeedVertex = false;
      draggedVertexIndex = -1;
      isDraggingCanvas = false;
      isAnimating = false;
      animationStartTime = 0;
      fromIterationCount = 1;
      toIterationCount = 2;
      ghostPoint = null;
      canvas.style.cursor = "crosshair";
      updateSnapToGridState();
      draw();
    });

    document.getElementById("resetCamera").addEventListener("click", () => {
      offsetX = 0;
      offsetY = 0;
      scale = 1;
      draw();
    });

    // Add event listener for loading presets
    document.getElementById("loadPreset").addEventListener("click", () => {
      const selectedPreset = document.getElementById("presetSelect").value;
      if (!selectedPreset || !presetCurves[selectedPreset]) return;
      
      // Reset the state
      iterationCount = 1;
      iterated = false;
      offsetX = 0;
      offsetY = 0;
      scale = 1;
      hoveredVertexIndex = -1;
      isDraggingSeedVertex = false;
      draggedVertexIndex = -1;
      isDraggingCanvas = false;
      isAnimating = false;
      animationStartTime = 0;
      fromIterationCount = 1;
      toIterationCount = 2;
      canvas.style.cursor = "crosshair";
      
      // Set the new seed pattern
      seed = presetCurves[selectedPreset].slice();
      
      draw();
    });

    // Add event listeners for grid controls
    const snapToGridCheckbox = document.getElementById("snapToGrid");
    
    gridTypeSelect.addEventListener("change", function() {
      gridType = this.value;
      updateSnapToGridState();
      draw();
    });
    
    gridSpacingInput.addEventListener("change", function() {
      gridSpacing = parseFloat(this.value);
      draw();
    });
    
    gridSpacingInput.addEventListener("input", function() {
      gridSpacing = parseFloat(this.value);
      draw();
    });
    
    snapToGridCheckbox.addEventListener("change", function() {
      snapToGrid = this.checked;
      draw();
    });
    
    function updateSnapToGridState() {
      // Enable snap to grid only if we have a grid
      snapToGridCheckbox.disabled = gridType === "none";
      if (snapToGridCheckbox.disabled) {
        snapToGridCheckbox.checked = false;
        snapToGrid = false;
      }
    }

    draw();
  </script>
</body>
</html>
