<!DOCTYPE html>
<html lang="en" >
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Fractal Curve Editor</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js"></script>
  <script>
    document.addEventListener("DOMContentLoaded", function() {
      // Wait for KaTeX to be loaded
      setTimeout(function() {
        renderMathInElement(document.body, {
          delimiters: [
            {left: "\\[", right: "\\]", display: true},
            {left: "\\(", right: "\\)", display: false}
          ]
        });
      }, 100);
    });
  </script>
  <style>
    :root {
      --bg-color: #121212;
      --card-bg: #1e1e1e;
      --primary-color: #bb86fc;
      --secondary-color: #03dac6;
      --text-color: #ffffff;
      --border-color: #333333;
      --hover-color: #2c2c2c;
    }
    
    body {
      background-color: var(--bg-color);
      color: var(--text-color);
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 0;
      padding: 0;
      line-height: 1.6;
      overflow: hidden; /* Hide scrollbars by default for the editor view */
    }
    
    .container {
      display: flex;
      flex-direction: row;
      height: 100vh;
      max-height: 100vh;
      overflow: hidden;
    }
    
    /* Adjust the flex ratio for wide screens */
    @media (min-width: 1600px) {
      .canvas-container {
        flex: 8;
      }
      
      .controls-container {
        flex: 2;
      }
    }
    
    /* This style is now defined below */
    
    .controls-container {
      flex: 3;
      background-color: var(--card-bg);
      padding: 20px;
      overflow-y: auto;
      border-left: 1px solid var(--border-color);
      box-shadow: -2px 0 10px rgba(0, 0, 0, 0.2);
    }
    
    h1 {
      margin-top: 0;
      margin-bottom: 20px;
      font-size: 24px;
      font-weight: 500;
    }
    
    h2 {
      font-size: 18px;
      margin-top: 0;
      margin-bottom: 15px;
      font-weight: 500;
      color: var(--secondary-color);
    }
    
    canvas {
      border: 1px solid var(--border-color);
      cursor: crosshair;
      background-color: black;
      display: block;
      border-radius: 4px;
      margin: 0 auto; /* Center horizontally */
    }
    
    .canvas-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      flex: 7;
      padding: 20px;
      overflow: hidden;
    }
    
    .control-card {
      background-color: var(--card-bg);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 20px;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
    }
    
    .control-group {
      margin-bottom: 15px;
    }
    
    .control-group:last-child {
      margin-bottom: 0;
    }
    
    .grid-controls {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 10px;
    }
    
    .input-group {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    button {
      background-color: var(--card-bg);
      color: var(--text-color);
      border: 1px solid var(--border-color);
      border-radius: 4px;
      padding: 8px 12px;
      cursor: pointer;
      transition: all 0.2s ease;
      font-size: 14px;
    }
    
    button:hover {
      background-color: var(--hover-color);
      border-color: var(--primary-color);
    }
    
    .primary-button {
      background-color: var(--primary-color);
      color: #000;
      border: none;
      font-weight: 500;
    }
    
    .primary-button:hover {
      background-color: #9969da;
      border: none;
    }
    
    .button-group {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    
    input[type="number"] {
      background-color: var(--card-bg);
      color: var(--text-color);
      border: 1px solid var(--border-color);
      border-radius: 4px;
      padding: 8px;
      width: 80px;
      font-size: 14px;
    }
    
    input[type="checkbox"] {
      accent-color: var(--primary-color);
    }
    
    select {
      background-color: var(--card-bg);
      color: var(--text-color);
      border: 1px solid var(--border-color);
      border-radius: 4px;
      padding: 8px;
      font-size: 14px;
    }
    
    #status {
      background-color: rgba(0, 0, 0, 0.2);
      border-radius: 4px;
      padding: 10px;
      margin-top: 15px;
      max-width: 100%;
      overflow: hidden;
    }
    
    .info-text {
      font-size: 14px;
      opacity: 0.8;
    }
    
    /* Modal styles */
    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.8);
      z-index: 1000;
      overflow-y: auto;
    }
    
    .modal-content {
      background-color: var(--card-bg);
      margin: 30px auto;
      max-width: 800px;
      width: 90%;
      border-radius: 8px;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
      animation: modalFadeIn 0.3s;
    }
    
    @keyframes modalFadeIn {
      from { opacity: 0; transform: translateY(-20px); }
      to { opacity: 1; transform: translateY(0); }
    }
    
    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 15px 20px;
      border-bottom: 1px solid var(--border-color);
    }
    
    .modal-header h2 {
      margin: 0;
    }
    
    .close-button {
      font-size: 28px;
      font-weight: bold;
      color: var(--text-color);
      cursor: pointer;
      transition: color 0.2s;
    }
    
    .close-button:hover {
      color: var(--primary-color);
    }
    
    .modal-body {
      padding: 20px;
      max-height: 70vh;
      overflow-y: auto;
    }
    
    @media (max-width: 768px) {
      .container {
        flex-direction: column;
      }
      
      .canvas-container {
        flex: none;
        height: 60vh;
      }
      
      .controls-container {
        flex: none;
        border-left: none;
        border-top: 1px solid var(--border-color);
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="canvas-container">
      <h1>Fractal Curve Editor</h1>
      <canvas id="canvas"></canvas>
      <div id="status"></div>
    </div>
    
    <div class="controls-container">
      <div class="control-card">
        <h2>Presets</h2>
        <div class="control-group">
          <select id="presetSelect">
            <option value="">Select a preset curve...</option>
            <option value="koch">Koch Curve</option>
            <option value="sierpinski">Sierpinski Triangle</option>
            <option value="crosses">Crosses</option>
            <option value="triangle_tiling">Triangle Tiling</option>
            <option value="levy">Levy C Curve</option>
            <option value="minkowski">Minkowski Sausage Curve</option>
            <option value="terdragon">Terdragon Curve</option>
          </select>
          <button id="loadPreset">Load Preset</button>
        </div>
      </div>
      
      <div class="control-card">
        <h2>Grid Settings</h2>
        <div class="control-group grid-controls">
          <div class="input-group">
            <label for="gridType">Type:</label>
            <select id="gridType">
              <option value="none">None</option>
              <option value="square">Square</option>
              <option value="hex">Hexagonal</option>
            </select>
          </div>
          
          <div class="input-group">
            <label for="gridSpacing">Size:</label>
            <input type="number" id="gridSpacing" min="0.05" max="2" value="0.5" step="0.05">
          </div>
          
          <div class="input-group">
            <input type="checkbox" id="snapToGrid" disabled>
            <label for="snapToGrid">Snap to grid</label>
          </div>
        </div>
      </div>
      
            <div class="control-card">
        <h2>Pattern Controls</h2>
        <div class="button-group">
          <button id="reset">Clear</button>
          <button id="resetIterations">Reset Iterations</button>
          <button id="iterate" class="primary-button">Iterate</button>
        </div>
      </div>
      
      <div class="control-card">
        <h2>Camera Controls</h2>
        <div class="button-group">
          <button id="resetCamera">Reset Camera</button>
          <button id="zoomToFit">Zoom to Fit</button>
        </div>
      </div>
      
      <div class="control-card">
        <h2>Controls</h2>
        <div class="info-text">
          <p><strong>Create Seed Pattern:</strong> Click on the canvas to add points</p>
          <p><strong>Move Points:</strong> Drag the red points to modify your pattern</p>
          <p><strong>Pan:</strong> Click and drag on the canvas to move the view</p>
          <p><strong>Zoom:</strong> Scroll to zoom in and out</p>
        </div>
      </div>
      
      <div class="control-card">
        <h2>About</h2>
        <div class="info-text">
          <p>This interactive editor lets you create custom fractal curves by defining a seed pattern and iterating it.</p>
          <p>Each iteration replaces every line segment with a transformed copy of your seed pattern.</p>
          <button id="showMath" style="width: 100%; margin-top: 10px;">Learn About the Math</button>
        </div>
      </div>
    </div>
  </div>
  
  <div class="modal" id="aboutModal">
    <div class="modal-content">
      <div class="modal-header">
        <h2>The Mathematics Behind Fractal Curves</h2>
        <span class="close-button">&times;</span>
      </div>
      <div class="modal-body">
        <div class="control-card">
          <h3>Fractal Generation</h3>
          <p>
            These fractal curves are created through an iterative process of replacing each line segment with a scaled, 
            rotated, and translated copy of a "seed pattern." This process is repeated for each new line segment 
            created, leading to increasingly complex patterns with self-similarity at different scales.
          </p>
          <p>
            The process works as follows:
          </p>
          <ol>
            <li>Start with a seed pattern (the points you create by clicking)</li>
            <li>For each line segment in the current curve, replace it with a transformed copy of the seed pattern</li>
            <li>Repeat step 2 for each new iteration</li>
          </ol>
        </div>
        
        <div class="control-card">
          <h3>Fractal Dimension</h3>
          <p>
            The fractal dimension is a measure of how "rough" or complex a fractal is.
            Unlike regular shapes that have integer dimensions (lines are 1D, squares are 2D), fractals can have 
            non-integer dimensions. The fractal dimension displayed is the fractal dimension of the curve you would get if you
            performed infinite iterations.
          </p>
          <p>
            For self-similar fractals like those created in this editor, the dimension \(D\) is calculated by solving 
            the equation:
          </p>
          <p style="text-align: center; margin: 20px 0;">
            \[ \sum_{i} r_i^D = 1 \]
          </p>
          <p>
            where \(r_i\) is the length of the \(i\)-th line segment of your seed pattern.
          </p>
          <p>
            The resulting dimension \(D\) tells us how "space-filling" the fractal is:
          </p>
          <ul>
            <li>\(D = 1\): The curve is essentially a line</li>
            <li>\(1 < D < 2\): The fractal is "rough" but doesn't fill a "solid" 2D area</li>
            <li>\(D \ge 2\): The fractal fills a "solid" 2D area</li>
          </ul>
          <p>
            For curves which grow larger and larger after more iterations, the fractal dimension is undefined because
            the curve doesn't "converge" in this case.
          </p>
        </div>
        
        <div class="control-card">
          <p>For more information on the math behind fractal dimension, check out this great video by 3blue1brown, which inspired this app:</p>
          <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%; border-radius: 8px;">
            <iframe style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;" src="https://www.youtube.com/embed/gB9n2gHsHN4?si=jIHznkcWJS36S5VW" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
          </div>
        </div>
      </div>
    </div>
  </div>
  <script>
    const canvas = document.getElementById("canvas");
    
    // Make the canvas square by using the smaller dimension
    // Calculate available space, leaving room for other elements
    const containerWidth = canvas.parentElement.clientWidth - 40; // Adjust for padding
    const containerHeight = window.innerHeight * 0.7; // Reduced to ensure info is visible
    
    // For wide screens (where width > height * 1.5), use a larger percentage of the container
    // but still ensure we don't cut off information below
    const isWideScreen = window.innerWidth > window.innerHeight * 1.5;
    const heightPercentage = isWideScreen ? 0.75 : 0.7;
    const adjustedContainerHeight = window.innerHeight * heightPercentage;
    
    const size = Math.min(containerWidth, adjustedContainerHeight);
    
    canvas.width = size;
    canvas.height = size;
    
    window.addEventListener('resize', function() {
      // Keep canvas square on resize
      const containerWidth = canvas.parentElement.clientWidth - 40;
      const containerHeight = window.innerHeight * 0.7; // Reduced to ensure info is visible
      
      // For wide screens (where width > height * 1.5), use a larger percentage of the container
      // but still ensure we don't cut off information below
      const isWideScreen = window.innerWidth > window.innerHeight * 1.5;
      const heightPercentage = isWideScreen ? 0.75 : 0.7;
      const adjustedContainerHeight = window.innerHeight * heightPercentage;
      
      const size = Math.min(containerWidth, adjustedContainerHeight);
      
      canvas.width = size;
      canvas.height = size;
      draw();
    });
    
    const ctx = canvas.getContext("2d");
    const statusDiv = document.getElementById("status");
    const gridTypeSelect = document.getElementById("gridType");
    const gridSpacingInput = document.getElementById("gridSpacing");

    // Grid settings
    let gridType = "none";
    let gridSpacing = 0.5;
    let snapToGrid = false;
    let ghostPoint = null;

    // Preset curves data structure
    const presetCurves = {
      koch: [
        [0, 0],
        [1/3, 0],
        [0.5, -Math.sqrt(3)/6],
        [2/3, 0],
        [1, 0]
      ],
      sierpinski: [
        [0, 0],
        [0.5, 0],
        [0.25, -Math.sqrt(3)/4],
        [0.75, -Math.sqrt(3)/4],
        [0.5, 0],
        [1, 0]
      ],
      crosses: [
        [0, 0],
        [0.5, 0],
        [0.5,-0.25],
        [0.5, 0],
        [1, 0]
      ],
      triangle_tiling: [
        [0, 0],
        [0.5, -Math.sqrt(3)/2],
        [1, 0],
      ],
      levy: [
        [0, 0],
        [0,-0.5],
        [0.5,-0.5],
        [1,-0.5],
        [1, 0],
      ],
      minkowski: [
        [0, 0],
        [0.25, 0],
        [0.25, -.25],
        [0.5, -.25],
        [0.5, 0],
        [0.5, 0.25],
        [0.75, 0.25],
        [0.75, 0],
        [1, 0],
      ],
      terdragon: [
        [0,0],
        [0.5, -1 / (Math.sqrt(3) * 2)],
        [0.5, 1 / (Math.sqrt(3) * 2)],
        [1,0],
      ],
    };

    let seed = [[0, 0], [1, 0]];

    let iterationCount = 1;
    let iterated = false;

    let offsetX = 0, offsetY = 0;
    let scale = 1;
    
    // Animation variables
    let isAnimating = false;
    let animationStartTime = 0;
    let animationDuration = 500; // Fixed at 500ms
    let fromIterationCount = 1;
    let toIterationCount = 2;

    let isDraggingCanvas = false;
    let dragStart = { x: 0, y: 0 };
    let isDraggingSeedVertex = false;
    let draggedVertexIndex = -1;
    let mouseMovedSinceDown = false;
    let mouseDownPos = { x: 0, y: 0 };
    const dragThreshold = 5; // Pixel threshold for considering a movement as a drag

    let hoveredVertexIndex = -1;

    const dotRadiusPx = 6;
    const seedPointRadius = 4;

    const linePaddingRatio = 0.15;

    const baseStartCanvas = [linePaddingRatio * canvas.width, canvas.height * .5];
    const baseEndCanvas = [canvas.width - linePaddingRatio * canvas.width, canvas.height * .5];

    function seedPointToCanvas([nx, ny]) {
      const dx = baseEndCanvas[0] - baseStartCanvas[0];
      const dy = baseEndCanvas[1] - baseStartCanvas[1];
      const lengthBase = Math.sqrt(dx*dx + dy*dy);
      const perpX = -dy / lengthBase;
      const perpY = dx / lengthBase;

      const x = baseStartCanvas[0] + nx * dx + ny * lengthBase * perpX;
      const y = baseStartCanvas[1] + nx * dy + ny * lengthBase * perpY;
      return [x, y];
    }

    function canvasToSeedPoint([cx, cy]) {
      const dx = baseEndCanvas[0] - baseStartCanvas[0];
      const dy = baseEndCanvas[1] - baseStartCanvas[1];
      const lengthBase = Math.sqrt(dx*dx + dy*dy);

      const vx = cx - baseStartCanvas[0];
      const vy = cy - baseStartCanvas[1];

      const dot = (vx*dx + vy*dy) / (lengthBase*lengthBase);
      const perpDot = (vx*(-dy) + vy*dx) / (lengthBase*lengthBase);

      return [dot, perpDot];
    }

    function computeFractalPoints(iterCount) {
      let currentPoints = [baseStartCanvas, baseEndCanvas];

      for (let iter = 0; iter < iterCount; iter++) {
        let newPoints = [];
        for (let i = 0; i < currentPoints.length - 1; i++) {
          const segStart = currentPoints[i];
          const segEnd = currentPoints[i + 1];

          const transformedPoints = seed.map(([nx, ny]) => {
            const vx = segEnd[0] - segStart[0];
            const vy = segEnd[1] - segStart[1];
            const len = Math.sqrt(vx*vx + vy*vy);
            const px = -vy / len;
            const py = vx / len;

            const x = segStart[0] + nx * vx + ny * len * px;
            const y = segStart[1] + nx * vy + ny * len * py;
            return [x, y];
          });

          if (i > 0) transformedPoints.shift();
          newPoints.push(...transformedPoints);
        }
        currentPoints = newPoints;
      }
      return currentPoints;
    }

    function computeFractalDimension() {
      let maxLen = 0;
      const lengths = [];

      for (let i = 0; i < seed.length - 1; i++) {
        const [x1, y1] = seed[i];
        const [x2, y2] = seed[i + 1];
        const dx = x2 - x1;
        const dy = y2 - y1;
        const len = Math.sqrt(dx * dx + dy * dy);
        if (len > maxLen) maxLen = len;
        lengths.push(len);
      }
      if (maxLen >= 1) return NaN;

      const tolerance = 1e-10;
      const maxIterations = 100;
      let D = 1.0;

      function f(D) {
        return lengths.reduce((sum, l) => sum + Math.pow(l, D), 0) - 1;
      }

      function fPrime(D) {
        return lengths.reduce((sum, l) => sum + Math.pow(l, D) * Math.log(l), 0);
      }

      for (let i = 0; i < maxIterations; i++) {
        const y = f(D);
        const yPrime = fPrime(D);
        if (Math.abs(yPrime) < 1e-12) break;
        const nextD = D - y / yPrime;
        if (Math.abs(nextD - D) < tolerance) return nextD;
        D = nextD;
      }
      return NaN;
    }

    function draw(animationProgress = -1) {
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      ctx.setTransform(scale, 0, 0, scale, offsetX, offsetY);
      
      // Draw grid if enabled
      drawGrid();
      
      ctx.lineWidth = 1 / scale;
      ctx.strokeStyle = "white";

      let fractalPoints;
      
      if (isAnimating && animationProgress >= 0 && animationProgress <= 1) {
        // During animation, interpolate between the two iteration levels
        const fromPoints = iterated ? 
          computeFractalPoints(fromIterationCount) : 
          seed.map(seedPointToCanvas);
          
        const toPoints = computeFractalPoints(toIterationCount);
        
        // Interpolate between the two sets of points
        fractalPoints = interpolatePoints(fromPoints, toPoints, animationProgress);
      } else if (iterated) {
        fractalPoints = computeFractalPoints(iterationCount);
      } else {
        fractalPoints = seed.map(seedPointToCanvas);
      }

      ctx.beginPath();
      ctx.moveTo(fractalPoints[0][0], fractalPoints[0][1]);
      for (let pt of fractalPoints.slice(1)) {
        ctx.lineTo(pt[0], pt[1]);
      }
      ctx.stroke();

      ctx.setTransform(1, 0, 0, 1, 0, 0);
      
      // Draw ghost point for snapping (only during creation phase)
      if (!iterated && ghostPoint && snapToGrid) {
        const [cx, cy] = seedPointToCanvas(ghostPoint);
        const sx = cx * scale + offsetX;
        const sy = cy * scale + offsetY;

        ctx.beginPath();
        ctx.fillStyle = "rgba(150, 150, 150, 0.7)";
        ctx.arc(sx, sy, seedPointRadius, 0, 2 * Math.PI);
        ctx.fill();
      }
      
      // Draw seed points
      for (let i = 0; i < seed.length; i++) {
        const [cx, cy] = seedPointToCanvas(seed[i]);
        const sx = cx * scale + offsetX;
        const sy = cy * scale + offsetY;

        ctx.beginPath();
        if (i === 0 || i === seed.length -1) {
          ctx.fillStyle = "white";
        } else {
          ctx.fillStyle = (i === hoveredVertexIndex) ? "lime" : "red";
        }
        ctx.arc(sx, sy, seedPointRadius, 0, 2 * Math.PI);
        ctx.fill();
      }

      let status = '';
      if (iterated) {
        status += `<div><strong>Iterations:</strong> ${iterationCount - 1}</div>`;
      } else {
        status += `<div><strong>Mode:</strong> Creating seed pattern</div>`;
      }
      
      const dim = computeFractalDimension();
      if (!isNaN(dim)) {
        status += `<div><strong>Fractal dimension:</strong> ${dim.toFixed(5)}</div>`;
      } else {
        status += `<div><strong>Fractal dimension:</strong> undefined</div>`;
      }
      statusDiv.innerHTML = status;
    }

    // Function to draw grid based on current view
    function drawGrid() {
      if (gridType === "none") return;
      
      // Calculate visible area in mathematical space
      // Convert from canvas coordinates to mathematical space
      const canvasToMath = (x, y) => {
        // First convert from canvas pixel to canvas space (accounting for scale and offset)
        const canvasX = (x - offsetX) / scale;
        const canvasY = (y - offsetY) / scale;
        // Then convert from canvas space to mathematical space
        return canvasToSeedPoint([canvasX, canvasY]);
      };
      
      const visibleLeftTop = canvasToMath(0, 0);
      const visibleRightBottom = canvasToMath(canvas.width, canvas.height);
      
      // Expand boundaries to ensure we cover the visible area
      const visibleLeft = Math.min(visibleLeftTop[0], visibleRightBottom[0]) - 1;
      const visibleRight = Math.max(visibleLeftTop[0], visibleRightBottom[0]) + 1;
      const visibleTop = Math.min(visibleLeftTop[1], visibleRightBottom[1]) - 1;
      const visibleBottom = Math.max(visibleLeftTop[1], visibleRightBottom[1]) + 1;
      
      // Grid spacing in mathematical units
      const mathSpacing = gridSpacing;
      
      // Set grid style
      ctx.lineWidth = 0.5 / scale;
      ctx.strokeStyle = "rgba(150, 150, 150, 0.5)";
      
      if (gridType === "square") {
        // Calculate grid boundaries aligned with mathematical (0,0)
        const startX = Math.floor(visibleLeft / mathSpacing) * mathSpacing;
        const startY = Math.floor(visibleTop / mathSpacing) * mathSpacing;
        const endX = Math.ceil(visibleRight / mathSpacing) * mathSpacing;
        const endY = Math.ceil(visibleBottom / mathSpacing) * mathSpacing;
        
        // Draw vertical grid lines
        for (let x = startX; x <= endX; x += mathSpacing) {
          // Convert mathematical coordinates to canvas coordinates
          const startPoint = seedPointToCanvas([x, visibleTop]);
          const endPoint = seedPointToCanvas([x, visibleBottom]);
          
          ctx.beginPath();
          ctx.moveTo(startPoint[0], startPoint[1]);
          ctx.lineTo(endPoint[0], endPoint[1]);
          ctx.stroke();
        }
        
        // Draw horizontal grid lines
        for (let y = startY; y <= endY; y += mathSpacing) {
          // Convert mathematical coordinates to canvas coordinates
          const startPoint = seedPointToCanvas([visibleLeft, y]);
          const endPoint = seedPointToCanvas([visibleRight, y]);
          
          ctx.beginPath();
          ctx.moveTo(startPoint[0], startPoint[1]);
          ctx.lineTo(endPoint[0], endPoint[1]);
          ctx.stroke();
        }
      } else if (gridType === "hex") {
        // For equilateral triangles with side length 1, we need:
        // - The spacing between parallel lines to be sin(60°) = √3/2
        // - The x-intercepts of the diagonal lines to be at intervals of 1
        
        const unitLength = mathSpacing; // This is our unit length (side of equilateral triangle)
        const lineSpacing = (Math.sqrt(3) / 2) * unitLength; // Height of equilateral triangle
        
        // Calculate visible area with padding
        const padding = 2 * unitLength;
        const extendedLeft = visibleLeft - padding;
        const extendedRight = visibleRight + padding;
        const extendedTop = visibleTop - padding;
        const extendedBottom = visibleBottom + padding;
        
        // Ensure grid is centered at (0,0)
        
        // For horizontal lines (at y = 0, ±lineSpacing, ±2*lineSpacing, etc.)
        const horizStartY = Math.floor(extendedTop / lineSpacing) * lineSpacing;
        const horizEndY = Math.ceil(extendedBottom / lineSpacing) * lineSpacing;
        
        // Draw horizontal lines
        for (let y = horizStartY; y <= horizEndY; y += lineSpacing) {
          const startPoint = seedPointToCanvas([extendedLeft, y]);
          const endPoint = seedPointToCanvas([extendedRight, y]);
          
          ctx.beginPath();
          ctx.moveTo(startPoint[0], startPoint[1]);
          ctx.lineTo(endPoint[0], endPoint[1]);
          ctx.stroke();
        }
        
        // For 60° lines (y = √3 * x + b)
        // The x-intercepts should be at intervals of unitLength
        const x60Offset = Math.floor(extendedLeft / unitLength) * unitLength;
        
        for (let xIntercept = x60Offset; xIntercept <= extendedRight; xIntercept += unitLength) {
          // Calculate start and end points for a line with this x-intercept
          const startX = extendedLeft;
          const startY = -Math.sqrt(3) * xIntercept + Math.sqrt(3) * startX;
          const endX = extendedRight;
          const endY = -Math.sqrt(3) * xIntercept + Math.sqrt(3) * endX;
          
          const startPoint = seedPointToCanvas([startX, startY]);
          const endPoint = seedPointToCanvas([endX, endY]);
          
          ctx.beginPath();
          ctx.moveTo(startPoint[0], startPoint[1]);
          ctx.lineTo(endPoint[0], endPoint[1]);
          ctx.stroke();
        }
        
        // For 120° lines (y = -√3 * x + b)
        // The x-intercepts should be at intervals of unitLength
        const x120Offset = Math.floor(extendedLeft / unitLength) * unitLength;
        
        for (let xIntercept = x120Offset; xIntercept <= extendedRight; xIntercept += unitLength) {
          // Calculate start and end points for a line with this x-intercept
          const startX = extendedLeft;
          const startY = Math.sqrt(3) * xIntercept - Math.sqrt(3) * startX;
          const endX = extendedRight;
          const endY = Math.sqrt(3) * xIntercept - Math.sqrt(3) * endX;
          
          const startPoint = seedPointToCanvas([startX, startY]);
          const endPoint = seedPointToCanvas([endX, endY]);
          
          ctx.beginPath();
          ctx.moveTo(startPoint[0], startPoint[1]);
          ctx.lineTo(endPoint[0], endPoint[1]);
          ctx.stroke();
        }
        
        // Draw a visual indicator for a unit equilateral triangle if close to origin
        if (Math.abs(offsetX) < canvas.width && Math.abs(offsetY) < canvas.height && scale > 50) {
          // Points for equilateral triangle with side length 1
          const triPoints = [
            [0, 0],
            [1, 0],
            [0.5, Math.sqrt(3)/2]
          ].map(p => seedPointToCanvas(p));
          
          ctx.beginPath();
          ctx.moveTo(triPoints[0][0], triPoints[0][1]);
          ctx.lineTo(triPoints[1][0], triPoints[1][1]);
          ctx.lineTo(triPoints[2][0], triPoints[2][1]);
          ctx.closePath();
          ctx.strokeStyle = "rgba(255, 255, 0, 0.5)";
          ctx.stroke();
          ctx.strokeStyle = "rgba(150, 150, 150, 0.5)";
        }
      }
    }

    function getSeedVertexUnderMouse(mx, my) {
      for (let i = 0; i < seed.length; i++) {
        if (i === 0 || i === seed.length - 1) continue;
        const [cx, cy] = seedPointToCanvas(seed[i]);
        const sx = cx * scale + offsetX;
        const sy = cy * scale + offsetY;
        const dx = mx - sx;
        const dy = my - sy;
        if (dx * dx + dy * dy <= dotRadiusPx * dotRadiusPx) {
          return i;
        }
      }
      return -1;
    }

    function updateSeedVertexPosition(index, fx, fy) {
      if (index === 0 || index === seed.length -1) return;
      seed[index] = canvasToSeedPoint([fx, fy]);
    }

    // Function to find nearest grid intersection point
    function findNearestGridIntersection(mathX, mathY) {
      if (gridType === "none") return [mathX, mathY];
      
      if (gridType === "square") {
        // For square grid, simply round to nearest grid spacing
        const nearestX = Math.round(mathX / gridSpacing) * gridSpacing;
        const nearestY = Math.round(mathY / gridSpacing) * gridSpacing;
        return [nearestX, nearestY];
      } else if (gridType === "hex") {
        // For hexagonal grid, we need to find the nearest intersection of our three line types
        
        // Height of equilateral triangle
        const height = (Math.sqrt(3) / 2) * gridSpacing;
        
        // First, find the nearest horizontal line
        const nearestY = Math.round(mathY / height) * height;
        
        // For the x-coordinate, it depends on which horizontal line we're on
        // If we're on an even-indexed horizontal line, intersections are at integer multiples of gridSpacing
        // If we're on an odd-indexed horizontal line, intersections are offset by gridSpacing/2
        const lineIndex = Math.round(nearestY / height);
        let xOffset = (lineIndex % 2 === 0) ? 0 : gridSpacing / 2;
        
        // Find nearest x-coordinate on this horizontal line
        const nearestX = Math.round((mathX - xOffset) / gridSpacing) * gridSpacing + xOffset;
        
        return [nearestX, nearestY];
      }
      
      return [mathX, mathY];
    }
    
    canvas.addEventListener("mousemove", e => {
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;

      // Only consider it a drag if movement exceeds threshold
      const dx = mx - mouseDownPos.x;
      const dy = my - mouseDownPos.y;
      const distSquared = dx * dx + dy * dy;
      
      if (distSquared > dragThreshold * dragThreshold) {
        mouseMovedSinceDown = true;
      }

      // Calculate mathematical coordinates
      const fx = (mx - offsetX) / scale;
      const fy = (my - offsetY) / scale;
      const mathPoint = canvasToSeedPoint([fx, fy]);
      
      // Update ghost point for snapping (only during creation phase)
      if (!iterated && snapToGrid) {
        ghostPoint = findNearestGridIntersection(mathPoint[0], mathPoint[1]);
        draw();
      } else {
        // Only redraw if we had a ghost point before
        if (ghostPoint) {
          ghostPoint = null;
          draw();
        }
      }

      if (isDraggingSeedVertex) {
        if (snapToGrid) {
          const snappedPoint = findNearestGridIntersection(mathPoint[0], mathPoint[1]);
          updateSeedVertexPosition(draggedVertexIndex, ...seedPointToCanvas(snappedPoint));
        } else {
          updateSeedVertexPosition(draggedVertexIndex, fx, fy);
        }
        draw();
        return;
      }

      const hovered = getSeedVertexUnderMouse(mx, my);
      if (hovered !== hoveredVertexIndex) {
        hoveredVertexIndex = hovered;
        canvas.style.cursor = hovered !== -1 ? "pointer" : (iterated ? "grab" : "crosshair");
        draw();
      }

      if (isDraggingCanvas) {
        offsetX = e.clientX - dragStart.x;
        offsetY = e.clientY - dragStart.y;
        draw();
      }
    });

    canvas.addEventListener("mousedown", e => {
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;

      mouseMovedSinceDown = false;
      mouseDownPos.x = mx;
      mouseDownPos.y = my;

      const vertexIndex = getSeedVertexUnderMouse(mx, my);
      if (vertexIndex !== -1) {
        isDraggingSeedVertex = true;
        draggedVertexIndex = vertexIndex;
        canvas.style.cursor = "grabbing";
        return;
      }

      isDraggingCanvas = true;
      dragStart.x = e.clientX - offsetX;
      dragStart.y = e.clientY - offsetY;
      canvas.style.cursor = "grabbing";
    });

    canvas.addEventListener("mouseup", e => {
      if (isDraggingSeedVertex) {
        isDraggingSeedVertex = false;
        draggedVertexIndex = -1;
        canvas.style.cursor = hoveredVertexIndex !== -1 ? "pointer" : "grab";
        return;
      }

      if (isDraggingCanvas) {
        isDraggingCanvas = false;
        canvas.style.cursor = hoveredVertexIndex !== -1 ? "pointer" : "grab";
        return;
      }
    });

    canvas.addEventListener("mouseleave", e => {
      if (isDraggingSeedVertex) {
        isDraggingSeedVertex = false;
        draggedVertexIndex = -1;
      }
      if (isDraggingCanvas) {
        isDraggingCanvas = false;
      }
      hoveredVertexIndex = -1;
      canvas.style.cursor = "crosshair";
      draw();
    });

    canvas.addEventListener("wheel", e => {
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;

      const wx = (mouseX - offsetX) / scale;
      const wy = (mouseY - offsetY) / scale;

      const zoom = e.deltaY < 0 ? 1.1 : 0.9;
      scale *= zoom;

      offsetX = mouseX - wx * scale;
      offsetY = mouseY - wy * scale;

      draw();
    });

    canvas.addEventListener("click", e => {
      if (iterated || isDraggingSeedVertex || isDraggingCanvas || mouseMovedSinceDown) return;

      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;

      const fx = (mx - offsetX) / scale;
      const fy = (my - offsetY) / scale;
      let newPoint = canvasToSeedPoint([fx, fy]);
      
      // If snap to grid is enabled, use the ghost point
      if (snapToGrid && ghostPoint) {
        newPoint = ghostPoint;
      }

      seed.splice(seed.length - 1, 0, newPoint);
      draw();
    });

    // Interpolate between two sets of points
    function interpolatePoints(fromPoints, toPoints, progress) {
      // Map the original segments to the new segments
      const result = [];
      
      // Find the mapping between original segments and new segments
      const segmentMap = mapSegmentsForAnimation(fromPoints, toPoints);
      
      // For each segment in the original curve
      for (let i = 0; i < segmentMap.length; i++) {
        const { originalStart, originalEnd, newPoints } = segmentMap[i];
        
        // Add the start point of this segment
        if (i === 0 || result[result.length - 1][0] !== originalStart[0] || result[result.length - 1][1] !== originalStart[1]) {
          result.push(originalStart);
        }
        
        // If there are intermediate points in this segment
        if (newPoints.length > 0) {
          // Calculate the midpoint of the original segment
          const midX = originalStart[0] + (originalEnd[0] - originalStart[0]) * 0.5;
          const midY = originalStart[1] + (originalEnd[1] - originalStart[1]) * 0.5;
          
          // For each new point, interpolate from the midpoint to its final position
          for (const newPoint of newPoints) {
            // Start from a position along the original segment
            const startX = midX;
            const startY = midY;
            
            // Interpolate to the final position
            result.push([
              startX + (newPoint[0] - startX) * progress,
              startY + (newPoint[1] - startY) * progress
            ]);
          }
        }
        
        // Add the end point of this segment
        result.push(originalEnd);
      }
      
      return result;
    }
    
    // Map original segments to new segments for animation
    function mapSegmentsForAnimation(fromPoints, toPoints) {
      const result = [];
      
      // If we're just starting with a seed pattern, handle it differently
      if (fromPoints.length <= 2) {
        // Just return a single segment with all the new points
        return [{
          originalStart: fromPoints[0],
          originalEnd: fromPoints[fromPoints.length - 1],
          newPoints: toPoints.slice(1, -1)
        }];
      }
      
      // Find the corresponding segments
      let toIndex = 0;
      
      for (let i = 0; i < fromPoints.length - 1; i++) {
        const originalStart = fromPoints[i];
        const originalEnd = fromPoints[i + 1];
        const newPoints = [];
        
        // Find the matching end point in the new curve
        let matchFound = false;
        while (toIndex < toPoints.length - 1) {
          // Add intermediate points
          newPoints.push(toPoints[toIndex]);
          toIndex++;
          
          // Check if we've found the matching end point
          if (Math.abs(toPoints[toIndex][0] - originalEnd[0]) < 0.001 && 
              Math.abs(toPoints[toIndex][1] - originalEnd[1]) < 0.001) {
            matchFound = true;
            break;
          }
        }
        
        // If we found a match, add this segment mapping
        if (matchFound) {
          result.push({
            originalStart,
            originalEnd,
            newPoints: newPoints.slice(1)  // Skip the start point as it's already included
          });
        }
      }
      
      // If we couldn't map properly, fall back to a simpler approach
      if (result.length === 0) {
        return [{
          originalStart: fromPoints[0],
          originalEnd: fromPoints[fromPoints.length - 1],
          newPoints: toPoints.slice(1, -1)
        }];
      }
      
      return result;
    }
    
    // Animation frame function
    function animateIteration(timestamp) {
      if (!animationStartTime) animationStartTime = timestamp;
      
      const elapsed = timestamp - animationStartTime;
      const progress = Math.min(elapsed / animationDuration, 1);
      
      draw(progress);
      
      if (progress < 1) {
        requestAnimationFrame(animateIteration);
      } else {
        // Animation complete
        isAnimating = false;
        animationStartTime = 0;
        iterationCount = toIterationCount;
        draw();
      }
    }

    document.getElementById("iterate").addEventListener("click", () => {
      if (isAnimating) return; // Don't start a new animation if one is in progress
      
      if (!iterated) {
        iterated = true;
        fromIterationCount = 1;
        toIterationCount = 2;
        canvas.style.cursor = "grab";
        updateSnapToGridState();
      } else {
        fromIterationCount = iterationCount;
        toIterationCount = iterationCount + 1;
      }
      
      // Start animation
      isAnimating = true;
      animationStartTime = 0;
      requestAnimationFrame(animateIteration);
    });

    document.getElementById("reset").addEventListener("click", () => {
      seed = [[0, 0], [1, 0]];
      iterationCount = 1;
      iterated = false;
      offsetX = 0;
      offsetY = 0;
      scale = 1;
      hoveredVertexIndex = -1;
      isDraggingSeedVertex = false;
      draggedVertexIndex = -1;
      isDraggingCanvas = false;
      isAnimating = false;
      animationStartTime = 0;
      fromIterationCount = 1;
      toIterationCount = 2;
      ghostPoint = null;
      canvas.style.cursor = "crosshair";
      updateSnapToGridState();
      draw();
    });

    document.getElementById("resetCamera").addEventListener("click", () => {
      offsetX = 0;
      offsetY = 0;
      scale = 1;
      draw();
    });
    
    // Reset iterations - returns to seed pattern without changing camera position
    document.getElementById("resetIterations").addEventListener("click", () => {
      if (iterated) {
        iterated = false;
        iterationCount = 1;
        canvas.style.cursor = "crosshair";
        updateSnapToGridState();
        draw();
      }
    });
    
    // Zoom to fit function - adjusts view to show all points
    document.getElementById("zoomToFit").addEventListener("click", () => {
      let points;
      
      if (iterated) {
        points = computeFractalPoints(iterationCount);
      } else {
        points = seed.map(seedPointToCanvas);
      }
      
      if (points.length === 0) return;
      
      // Find min/max coordinates to determine bounding box
      let minX = Infinity, minY = Infinity;
      let maxX = -Infinity, maxY = -Infinity;
      
      for (const [x, y] of points) {
        minX = Math.min(minX, x);
        minY = Math.min(minY, y);
        maxX = Math.max(maxX, x);
        maxY = Math.max(maxY, y);
      }
      
      // Add padding (10% on each side)
      const width = maxX - minX;
      const height = maxY - minY;
      const padding = Math.max(width, height) * 0.1;
      
      minX -= padding;
      minY -= padding;
      maxX += padding;
      maxY += padding;
      
      // Calculate center of bounding box
      const centerX = (minX + maxX) / 2;
      const centerY = (minY + maxY) / 2;
      
      // Calculate scale to fit
      const canvasWidth = canvas.width;
      const canvasHeight = canvas.height;
      const scaleX = canvasWidth / (maxX - minX);
      const scaleY = canvasHeight / (maxY - minY);
      const newScale = Math.min(scaleX, scaleY) * 0.95; // 95% to ensure a small margin
      
      // Calculate new offsets to center the bounding box
      const newOffsetX = canvasWidth / 2 - centerX * newScale;
      const newOffsetY = canvasHeight / 2 - centerY * newScale;
      
      // Apply new scale and offsets
      scale = newScale;
      offsetX = newOffsetX;
      offsetY = newOffsetY;
      
      draw();
    });

    // Add event listener for loading presets
    document.getElementById("loadPreset").addEventListener("click", () => {
      const selectedPreset = document.getElementById("presetSelect").value;
      if (!selectedPreset || !presetCurves[selectedPreset]) return;
      
      // Reset the state
      iterationCount = 1;
      iterated = false;
      offsetX = 0;
      offsetY = 0;
      scale = 1;
      hoveredVertexIndex = -1;
      isDraggingSeedVertex = false;
      draggedVertexIndex = -1;
      isDraggingCanvas = false;
      isAnimating = false;
      animationStartTime = 0;
      fromIterationCount = 1;
      toIterationCount = 2;
      canvas.style.cursor = "crosshair";
      
      // Set the new seed pattern
      seed = presetCurves[selectedPreset].slice();
      
      draw();
    });

    // Add event listeners for grid controls
    const snapToGridCheckbox = document.getElementById("snapToGrid");
    
    gridTypeSelect.addEventListener("change", function() {
      gridType = this.value;
      updateSnapToGridState();
      draw();
    });
    
    gridSpacingInput.addEventListener("change", function() {
      gridSpacing = parseFloat(this.value);
      draw();
    });
    
    gridSpacingInput.addEventListener("input", function() {
      gridSpacing = parseFloat(this.value);
      draw();
    });
    
    snapToGridCheckbox.addEventListener("change", function() {
      snapToGrid = this.checked;
      draw();
    });
    
    function updateSnapToGridState() {
      // Enable snap to grid only if we have a grid
      snapToGridCheckbox.disabled = gridType === "none";
      if (snapToGridCheckbox.disabled) {
        snapToGridCheckbox.checked = false;
        snapToGrid = false;
      }
    }

    // Modal functionality
    const modal = document.getElementById("aboutModal");
    const showMathBtn = document.getElementById("showMath");
    const closeBtn = document.querySelector(".close-button");
    
    // Open modal when clicking "Learn About the Math"
    showMathBtn.addEventListener("click", function() {
      modal.style.display = "block";
      document.body.style.overflow = "hidden"; // Prevent scrolling behind modal
    });
    
    // Close modal when clicking X
    closeBtn.addEventListener("click", function() {
      modal.style.display = "none";
      document.body.style.overflow = "hidden"; // Keep main view without scrollbars
    });
    
    // Close modal when clicking outside of it
    window.addEventListener("click", function(event) {
      if (event.target === modal) {
        modal.style.display = "none";
        document.body.style.overflow = "hidden";
      }
    });
    
    // Close modal with Escape key
    window.addEventListener("keydown", function(event) {
      if (event.key === "Escape" && modal.style.display === "block") {
        modal.style.display = "none";
        document.body.style.overflow = "hidden";
      }
    });
    
    // Initialize
    draw();
  </script>
</body>
</html>
