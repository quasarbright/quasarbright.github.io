/**
 * @fileoverview Core type definitions and utility functions for the Image Column Sorter.
 * 
 * This module defines the data structures used throughout the application.
 * Key design principle: Sorting operates on pure number arrays (column indices),
 * completely independent of image data for performance and testability.
 */

/**
 * Represents a single step in the sorting algorithm visualization.
 * This is a discriminated union type with three possible variants.
 * 
 * @typedef {Object} CompareStep
 * @property {'compare'} type - Indicates a comparison operation
 * @property {[number, number]} indices - The two array positions being compared
 */

/**
 * @typedef {Object} SwapStep
 * @property {'swap'} type - Indicates a swap operation
 * @property {[number, number]} indices - The two array positions being swapped
 */

/**
 * @typedef {Object} CompleteStep
 * @property {'complete'} type - Indicates sorting has finished
 */

/**
 * A sorting step can be one of three types: compare, swap, or complete.
 * This discriminated union pattern allows type-safe handling of different step types.
 * 
 * @typedef {CompareStep | SwapStep | CompleteStep} SortingStep
 */

/**
 * Represents the order of columns in the visualization.
 * This is a simple array of numbers where:
 * - columnOrder[displayPosition] = sourceColumnIndex
 * - Example: [5, 2, 8, 1] means display position 0 shows source column 5,
 *   display position 1 shows source column 2, etc.
 * 
 * This design is memory efficient (just integers) and fast to manipulate.
 * Sorting algorithms work directly on this array.
 * 
 * @typedef {number[]} ColumnOrder
 */

/**
 * Represents a visual highlight overlay on columns during sorting.
 * 
 * @typedef {Object} Highlight
 * @property {number[]} indices - Array positions to highlight
 * @property {string} color - RGBA color string with transparency
 * @property {'comparison' | 'operation'} type - Type of highlight
 */

/**
 * Represents the current state of the visualization animation.
 * 
 * @typedef {Object} VisualizationState
 * @property {boolean} isPlaying - Whether animation is currently running
 * @property {boolean} isPaused - Whether animation is paused
 * @property {number} currentStepIndex - Index of current step being executed
 * @property {number} speed - Delay between steps in milliseconds
 */

/**
 * Central application state containing all data needed for the visualization.
 * 
 * @typedef {Object} ApplicationState
 * @property {HTMLImageElement | null} sourceImage - Original loaded image
 * @property {number} imageWidth - Number of columns in the image
 * @property {ColumnOrder} columnOrder - Current display order of columns
 * @property {ColumnOrder} scrambledOrder - Saved scrambled state for reset
 * @property {Object | null} selectedAlgorithm - Currently selected sorting algorithm
 * @property {SortingStep[]} sortingSteps - Array of steps generated by algorithm
 * @property {VisualizationState} visualizationState - Current animation state
 * @property {boolean} audioEnabled - Whether audio feedback is enabled
 * @property {Highlight[]} highlights - Current visual highlights on columns
 */

/**
 * Creates an identity column order [0, 1, 2, ..., n-1].
 * This represents the original, unscrambled state.
 * 
 * @param {number} length - Number of columns
 * @returns {ColumnOrder} Array of indices in sequential order
 */
export function createIdentityOrder(length) {
    return Array.from({ length }, (_, i) => i);
}

/**
 * Creates a copy of a column order array.
 * 
 * @param {ColumnOrder} order - Column order to copy
 * @returns {ColumnOrder} New array with same values
 */
export function copyColumnOrder(order) {
    return [...order];
}

/**
 * Swaps two elements in a column order array (in-place).
 * 
 * @param {ColumnOrder} order - Column order array to modify
 * @param {number} i - First index
 * @param {number} j - Second index
 */
export function swapColumns(order, i, j) {
    const temp = order[i];
    order[i] = order[j];
    order[j] = temp;
}

/**
 * Compares two columns based on their original positions.
 * This is the fundamental comparison function used by all sorting algorithms.
 * 
 * The comparison is based on the numeric values in the columnOrder array,
 * which represent the original source column indices. Lower values should
 * come before higher values to restore the original image.
 * 
 * @param {ColumnOrder} order - Current column order
 * @param {number} i - First position to compare
 * @param {number} j - Second position to compare
 * @returns {number} Negative if order[i] < order[j], positive if order[i] > order[j], 0 if equal
 */
export function compareColumns(order, i, j) {
    return order[i] - order[j];
}

/**
 * Checks if a column order represents the sorted (original) state.
 * A sorted order has columns in ascending order: [0, 1, 2, ..., n-1].
 * 
 * @param {ColumnOrder} order - Column order to check
 * @returns {boolean} True if columns are in sorted order
 */
export function isSorted(order) {
    for (let i = 0; i < order.length - 1; i++) {
        if (order[i] > order[i + 1]) {
            return false;
        }
    }
    return true;
}

/**
 * Validates that a column order is a valid permutation.
 * A valid permutation contains each number from 0 to n-1 exactly once.
 * 
 * @param {ColumnOrder} order - Column order to validate
 * @returns {boolean} True if order is a valid permutation
 */
export function isValidPermutation(order) {
    const seen = new Set();
    for (let i = 0; i < order.length; i++) {
        if (order[i] < 0 || order[i] >= order.length || seen.has(order[i])) {
            return false;
        }
        seen.add(order[i]);
    }
    return seen.size === order.length;
}

/**
 * Scrambles a column order array using the Fisher-Yates shuffle algorithm.
 * This is a pure function that creates a new shuffled array from [0, 1, 2, ..., length-1].
 * 
 * The Fisher-Yates shuffle ensures each permutation has equal probability,
 * providing a truly random scramble of the columns.
 * 
 * @param {number} length - Number of columns to scramble
 * @returns {ColumnOrder} New array with shuffled indices
 */
export function scrambleColumns(length) {
    // Create identity order [0, 1, 2, ..., length-1]
    const order = createIdentityOrder(length);
    
    // Fisher-Yates shuffle algorithm
    // Iterate from the end to the beginning
    for (let i = order.length - 1; i > 0; i--) {
        // Pick a random index from 0 to i (inclusive)
        const j = Math.floor(Math.random() * (i + 1));
        
        // Swap elements at positions i and j
        const temp = order[i];
        order[i] = order[j];
        order[j] = temp;
    }
    
    return order;
}
