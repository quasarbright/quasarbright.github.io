<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Julia Set Image Transformer</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .container {
            width: 100%;
            max-width: 800px;
        }
        .controls {
            margin-bottom: 20px;
            padding: 15px;
            background-color: white;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        canvas {
            display: block;
            margin: 0 auto;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }
        #imageUpload {
            margin-bottom: 10px;
        }
        .instructions {
            margin-top: 20px;
            padding: 15px;
            background-color: white;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .slider-container {
            margin: 10px 0;
        }
        input[type="range"] {
            width: 100%;
        }
        .button-group {
            margin-top: 15px;
            display: flex;
            gap: 10px;
        }
        button {
            padding: 8px 15px;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            flex: 1;
        }
        #saveButton {
            background-color: #4CAF50;
        }
        #resetButton {
            background-color: #2196F3;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Julia Set Image Transformer</h1>
        
        <div class="controls">
            <input type="file" id="imageUpload" accept="image/*">
            <div>
                <p>Click or drag on the canvas to set the Julia set parameter c in f(z) = z² + c</p>
                <p>Current c: <span id="cValue">0 + 0i</span></p>
                <div class="slider-container">
                    <label for="iterationSlider">Iterations: <span id="iterationValue">50</span></label>
                    <input type="range" id="iterationSlider" min="10" max="200" value="50">
                </div>
                <div class="slider-container">
                    <label for="tileSlider">Tile Size: <span id="tileValue">2.0</span></label>
                    <input type="range" id="tileSlider" min="0.1" max="5.0" value="2.0" step="0.1">
                </div>
                <div class="button-group">
                    <button id="resetButton" disabled>Reset Parameters</button>
                    <button id="saveButton" disabled>Save Image</button>
                </div>
            </div>
        </div>
        
        <canvas id="glCanvas" width="600" height="600"></canvas>
        
        <div class="instructions">
            <h3>Instructions:</h3>
            <ol>
                <li>Upload an image using the button above</li>
                <li>Click or drag on the canvas to set the Julia set parameter c</li>
                <li>The algorithm maps each pixel through the function f(z) = z² + c</li>
                <li>Pixels are colored based on where they end up in the original image</li>
                <li>Adjust the tile size to vary how the image is used in the transformation</li>
            </ol>
            
            <h4>Tiling Approach:</h4>
            <p>The image is tiled across the complex plane in a grid pattern. The tile size controls how many copies of the image appear in the complex plane. Smaller tile sizes create more copies, which can help use more of the image's colors.</p>
            <p>Each tile is divided into four quadrants, each using a different mapping of the image (normal, flipped horizontally, flipped vertically, and rotated 180°). This ensures more variety in the colors used.</p>
            
            <h4>Keyboard Shortcuts:</h4>
            <ul>
                <li><strong>S</strong> - Save the current image</li>
                <li><strong>+/-</strong> - Increase/decrease iterations</li>
                <li><strong>,/.</strong> - Decrease/increase tile size</li>
            </ul>
        </div>
    </div>

    <script type="x-shader/x-vertex" id="vertexShader">
        attribute vec2 a_position;
        varying vec2 v_texCoord;

        void main() {
            gl_Position = vec4(a_position, 0.0, 1.0);
            v_texCoord = a_position * 0.5 + 0.5;
        }
    </script>

    <script type="x-shader/x-fragment" id="fragmentShader">
        precision highp float;
        
        uniform sampler2D u_image;
        uniform vec2 u_resolution;
        uniform vec2 u_juliaC;
        uniform float u_tileSize;
        uniform int u_maxIterations;
        
        varying vec2 v_texCoord;

        void main() {
            // Map pixel coordinates to complex plane (-2 to 2)
            vec2 z = (v_texCoord * 2.0 - 1.0) * 2.0;
            
            bool escaped = false;
            
            // Julia set iteration
            for (int i = 0; i < 1000; i++) {
                if (i >= u_maxIterations) break;
                
                // z^2 + c
                float zx2 = z.x * z.x - z.y * z.y;
                float zy2 = 2.0 * z.x * z.y;
                z.x = zx2 + u_juliaC.x;
                z.y = zy2 + u_juliaC.y;
                
                // Check if point escapes
                if (z.x * z.x + z.y * z.y > 4.0) {
                    escaped = true;
                    break;
                }
            }
            
            if (escaped) {
                // If point escapes (diverges), use original image color at that position
                // This helps preserve more of the original image
                // Flip the y-coordinate to correct the upside-down issue
                vec2 origCoord = vec2(v_texCoord.x, 1.0 - v_texCoord.y);
                
                // Darken the original color to distinguish it from non-escaped points
                gl_FragColor = texture2D(u_image, origCoord) * 0.3;
            } else {
                // For non-escaped points, use a tiling approach
                // Scale the complex coordinates
                vec2 scaled = z * 100.0;
                
                // Then use a tiling approach by taking modulo of the scaled coordinates
                // This creates a grid of image tiles in the complex plane
                float halfTile = u_tileSize * 0.5;
                vec2 tiled = mod(mod(scaled, u_tileSize) + u_tileSize, u_tileSize);
                
                // Determine which quadrant of the tile we're in
                vec2 imgCoord;
                
                // Top-left quadrant - normal mapping
                if (tiled.x < halfTile && tiled.y < halfTile) {
                    imgCoord = vec2(tiled.x / halfTile * 0.5, tiled.y / halfTile * 0.5);
                }
                // Top-right quadrant - flipped horizontally
                else if (tiled.x >= halfTile && tiled.y < halfTile) {
                    imgCoord = vec2((1.0 - (tiled.x - halfTile) / halfTile) * 0.5, tiled.y / halfTile * 0.5);
                }
                // Bottom-left quadrant - flipped vertically
                else if (tiled.x < halfTile && tiled.y >= halfTile) {
                    imgCoord = vec2(tiled.x / halfTile * 0.5, (1.0 - (tiled.y - halfTile) / halfTile) * 0.5);
                }
                // Bottom-right quadrant - rotated 180 degrees
                else {
                    imgCoord = vec2((1.0 - (tiled.x - halfTile) / halfTile) * 0.5, (1.0 - (tiled.y - halfTile) / halfTile) * 0.5);
                }
                
                // Offset to use full texture space
                imgCoord += vec2(0.25, 0.25);
                
                // Flip the y-coordinate to correct the upside-down issue
                imgCoord.y = 1.0 - imgCoord.y;
                
                gl_FragColor = texture2D(u_image, imgCoord);
            }
        }
    </script>

    <script src="script.js"></script>
</body>
</html> 