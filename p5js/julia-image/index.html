<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Julia Set Image Transformer</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .container {
            width: 100%;
            max-width: 800px;
        }
        .controls {
            margin-bottom: 20px;
            padding: 15px;
            background-color: white;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        canvas {
            display: block;
            margin: 0 auto;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }
        #imageUpload {
            margin-bottom: 10px;
        }
        .instructions {
            margin-top: 20px;
            padding: 15px;
            background-color: white;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .slider-container {
            margin: 10px 0;
        }
        input[type="range"] {
            width: 100%;
        }
        .button-group {
            margin-top: 15px;
            display: flex;
            gap: 10px;
        }
        button {
            padding: 8px 15px;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            flex: 1;
        }
        #saveButton {
            background-color: #4CAF50;
        }
        #resetButton {
            background-color: #2196F3;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Julia Set Image Transformer</h1>
        
        <div class="controls">
            <input type="file" id="imageUpload" accept="image/*">
            <div>
                <p>Click or drag on the canvas to set the Julia set parameter c in f(z) = z² + c</p>
                <p>Current c: <span id="cValue">0 + 0i</span></p>
                <div class="slider-container">
                    <label for="iterationSlider">Iterations: <span id="iterationValue">50</span></label>
                    <input type="range" id="iterationSlider" min="10" max="200" value="50">
                </div>
                <div class="slider-container">
                    <label for="tileSlider">Tile Size: <span id="tileValue">2.0</span></label>
                    <input type="range" id="tileSlider" min="0.1" max="5.0" value="2.0" step="0.1">
                </div>
                <div class="button-group">
                    <button id="resetButton" disabled>Reset Parameters</button>
                    <button id="saveButton" disabled>Save Image</button>
                </div>
            </div>
        </div>
        
        <canvas id="glCanvas" width="600" height="600"></canvas>
        
        <div class="instructions">
            <h3>Instructions:</h3>
            <ol>
                <li>Upload an image using the button above</li>
                <li>Click or drag on the canvas to set the Julia set parameter c</li>
                <li>Use the mouse wheel to zoom in and out</li>
                <li>The algorithm maps each pixel through the function f(z) = z² + c</li>
                <li>The image appears only in the fractal pattern (non-escaping points)</li>
                <li>Adjust the tile size to vary how the image is used in the transformation</li>
            </ol>
            
            <h4>Tiling Approach:</h4>
            <p>The image is tiled across the complex plane within the fractal pattern. The tile size controls how many copies of the image appear in the complex plane. Smaller tile sizes create more copies, which can help use more parts of the image.</p>
            
            <h4>Keyboard Shortcuts:</h4>
            <ul>
                <li><strong>S</strong> - Save the current image</li>
                <li><strong>+/-</strong> - Increase/decrease iterations</li>
                <li><strong>,/.</strong> - Decrease/increase tile size</li>
                <li><strong>Mouse Wheel</strong> - Zoom in/out at cursor position</li>
            </ul>
        </div>
    </div>

    <script type="x-shader/x-vertex" id="vertexShader">
        attribute vec2 a_position;
        varying vec2 v_texCoord;

        void main() {
            gl_Position = vec4(a_position, 0.0, 1.0);
            v_texCoord = a_position * 0.5 + 0.5;
        }
    </script>

    <script type="x-shader/x-fragment" id="fragmentShader">
        precision highp float;
        
        uniform sampler2D u_image;
        uniform vec2 u_resolution;
        uniform vec2 u_juliaC;
        uniform float u_tileSize;
        uniform int u_maxIterations;
        uniform vec2 u_center;
        uniform float u_zoom;
        
        varying vec2 v_texCoord;

        // Convert texture coordinates to complex plane coordinates
        vec2 toComplex(vec2 coord) {
            // Convert from [0,1] to [-1,1] range
            vec2 ndc = coord * 2.0 - 1.0;
            
            // Apply aspect ratio correction
            float aspectRatio = u_resolution.x / u_resolution.y;
            if (aspectRatio > 1.0) {
                ndc.x *= aspectRatio;
            } else {
                ndc.y /= aspectRatio;
            }
            
            // Apply zoom and center offset
            return ndc * (2.0 / u_zoom) + u_center;
        }

        void main() {
            // Map pixel coordinates to complex plane with zoom and center
            vec2 z = toComplex(v_texCoord);
            
            bool escaped = false;
            
            // Julia set iteration
            for (int i = 0; i < 1000; i++) {
                if (i >= u_maxIterations) break;
                
                // z^2 + c
                float zx2 = z.x * z.x - z.y * z.y;
                float zy2 = 2.0 * z.x * z.y;
                z.x = zx2 + u_juliaC.x;
                z.y = zy2 + u_juliaC.y;
                
                // Check if point escapes
                if (z.x * z.x + z.y * z.y > 4.0) {
                    escaped = true;
                    break;
                }
            }
            
            if (escaped) {
                // If point escapes (diverges), use a solid background color
                gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0); // Black background
            } else {
                // For non-escaped points, use a simple tiling approach
                // Scale the complex coordinates by a factor to create more detail
                vec2 scaled = z * 10.0;
                
                // Apply modulo to create tiling effect with the full image
                // Divide by tileSize to control number of tiles
                vec2 tiled = mod(scaled / u_tileSize + 0.5, 1.0);
                
                // Flip the y-coordinate to correct the upside-down issue
                tiled.y = 1.0 - tiled.y;
                
                gl_FragColor = texture2D(u_image, tiled);
            }
        }
    </script>

    <script src="script.js"></script>
</body>
</html> 